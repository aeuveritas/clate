#!/usr/bin/env python3

import argparse
import os
import json
import shutil

import docker

CLATE_JSON = os.getenv("HOME") + '/.clate.json'

AVAILABLE_VERSION = [
    '0.1',
    '0.2',
]


class Docker:
    def __init__(self):
        self._client = docker.from_env()

    def get_names(self):
        names = list()
        for container in self._client.containers.list():
            if "clate_" in container.name:
                names.append(container.name.replace("clate_", ""))

        return names

    def _traverse(self, name, func=None):
        target_name = "clate_{}".format(name)
        for container in self._client.containers.list():
            if target_name == container.name:
                if func:
                    func(container)
                return True

        return False

    def is_running(self, name):
        return self._traverse(name)

    def stop(self, name):
        return self._traverse(name, lambda obj: obj.stop())


class DirManager:
    def exDir(self, new_dir):
        if os.path.exists(new_dir):
            return True
        return False

    def endSlash(self, new_dir):
        if new_dir[-1] != '/':
            new_dir += '/'
        return new_dir

    def mkDir(self, new_dir):
        try:
            os.makedirs(new_dir)
        except OSError as e:
            print(e)

    def rmDir(self, t_dir):
        try:
            shutil.rmtree(t_dir)
        except shutil.Error as e:
            print(e)


class Interactor:
    def __init__(self, dirMgr):
        self._dirMgr = dirMgr

    def menu(self):
        print('   \x1b[1;32;40m' + "[C]" + '\x1b[0m' + "reate new project")
        print('   \x1b[1;32;40m' + "[L]" + '\x1b[0m' + "ist projects")
        print('   \x1b[1;32;40m' + "[A]" + '\x1b[0m' + "ctivate project")
        print('lis\x1b[1;32;40m' + "[T]" + '\x1b[0m' + " running project")
        print('  d\x1b[1;32;40m' + "[E]" + '\x1b[0m' + "lete proect")
        print('')
        print(' st\x1b[1;32;40m' + "[O]" + '\x1b[0m' + "p running project")
        print('cha\x1b[1;32;40m' + "[N]" + '\x1b[0m' + "ge version")
        print('')
        print('  e\x1b[1;32;40m' + "[X]" + '\x1b[0m' + "it")

        cmd = ""
        try:
            cmd = input("[ ASK ] command: ")
        except (KeyboardInterrupt):
            cmd = "x"

        return cmd

    def print_list(self, items):
        for (i, item) in enumerate(items):
            print("{0}: {1}".format(i, item))

    def list_select(self, items):
        ret = -1
        if len(items) == 0:
            return ret

        self.print_list(items)

        try:
            num = int(input("[ ASK ] select: "))
            if num <= len(items) and num >= 0:
                ret = num
        except (TypeError, ValueError, KeyboardInterrupt):
            print("[ WAR ] wrong input")

        return ret

    def binary_select(self):
        try:
            confirm = input("[ ASK ] confirm(y/N): ")
            if confirm in ('y', 'Y'):
                return True
        except (TypeError, ValueError, KeyboardInterrupt):
            print("[ WAR ] wrong input")

        return False

    def fill_project(self, name_list, default_version):
        try:
            project_name = input("[ ASK ] project name: ")

            if project_name in name_list:
                print("[ WAR ] already existed: {}".format(project_name))
                return

            import readline
            import glob

            def complete(text, state):
                return (glob.glob(text+'*')+[None])[state]
            readline.set_completer_delims(' \t\n;')
            readline.parse_and_bind("tab: complete")
            readline.set_completer(complete)

            project_path = input("[ ASK ] project directory: ")
            if not self._dirMgr.exDir(project_path):
                print("[ WAR ] not existed: {}".format(project_path))
                return
            project_path = self._dirMgr.endSlash(project_path)

            dirs = dict()
            dirs['Workspace'] = project_path

            while True:
                need_more = input("[ ASK ] additonal directory(y/N): ")
                if need_more in ('y', 'Y'):
                    new_name = input("[ ASK ] directory name: ")

                    new_path = input("[ ASK ] directory path: ")
                    if not self._dirMgr.exDir(new_path):
                        print("[ WAR ] not existed: {}".format(new_path))
                        continue

                    self._dirMgr.endSlash(new_path)
                    dirs[new_name] = new_path
                else:
                    break

            new_project = dict()
            new_project['name'] = project_name
            new_project['version'] = default_version
            new_project['directory'] = dirs

            return new_project
        except KeyboardInterrupt:
            pass

        return None


class Setting_Manager:
    def update(self):
        clate_json = open(CLATE_JSON, 'r')
        data = json.loads(clate_json.read())
        clate_json.close()

        return data['common'], data['project']

    def flush(self, common, project):
        data = dict()
        data['common'] = common
        data['project'] = project

        clate_json = open(CLATE_JSON, 'w')
        clate_json.write(json.dumps(data, sort_keys=True, indent=4))
        clate_json.close()


class Clate:
    def __init__(self):
        self._common = None
        self._project = None
        self._project_names = None

        self._dirMgr = DirManager()
        self._interactor = Interactor(self._dirMgr)
        self._setting = Setting_Manager()
        self._docker = Docker()

        self._common, self._project = self._setting.update()
        self._build_project_names()

        print("[ INF ] Clate - {0}".format(self._common['default_version']))

    def _build_project_names(self):
        del self._project_names
        self._project_names = list()
        for project in self._project:
            self._project_names.append(project['name'])

    def console(self):
        is_finish = False

        while not is_finish:
            cmd = self._interactor.menu()

            if cmd == 'c':
                self._create()
            elif cmd == 'l':
                self._show()
            elif cmd == 'a':
                self._run()
            elif cmd == 't':
                self._show_running_project()
            elif cmd == 'e':
                self._delete()
            elif cmd == 'n':
                self._change_version()
            elif cmd == 'o':
                self._stop()
            elif cmd == 'x':
                return
            else:
                print("[ WAR ] wrong command")

            print("")

    def _get_running_project(self):
        return self._docker.get_names()

    def _show_running_project(self):
        names = self._get_running_project()
        self._interactor.print_list(names)

    def _stop(self):
        names = self._get_running_project()
        num = self._interactor.list_select(names)

        if num != -1:
            project_name = names[num]
            ret = self._docker.stop(project_name)
            if ret:
                print("[ SUC ] stopped: {}".format(project_name))
            else:
                print("[ WAR ] cannot find running clate: {}".format(project_name))

    def _show(self):
        print("COMMON")
        print(json.dumps(self._common, indent=4, sort_keys=True))
        print("PROJECT")
        print(json.dumps(self._project, indent=4, sort_keys=True))

    def _createTempDir(self, new_project):
        temp_dir = self._common['directory']['Path'] + 'Temp/' + new_project['name'] + '/'
        new_project['directory']['Temp'] = temp_dir
        self._dirMgr.mkDir(temp_dir)

    def _create(self):
        new_project = self._interactor.fill_project(self._project_names, self._common['default_version'])

        if new_project:
            self._createTempDir(new_project)
            self._project.append(new_project)
            self._build_project_names()
            self._setting.flush(self._common, self._project)
            print("[ SUC ] created: {}".format(new_project))

    def _delete(self):
        project_num = self._interactor.list_select(self._project_names)

        if project_num != -1:
            if project_num == 0:
                print("[ WAR ] project - Clate is not earasable.")
            else:
                project_name = self._project_names[project_num]
                if not self._docker.is_running(project_name):
                    confirm = self._interactor.binary_select()
                    if confirm:
                        self._dirMgr.rmDir(self._project[project_num]['directory']['Temp'])
                        del self._project[project_num]
                        self._build_project_names()
                        print("[ SUC ] deleted: {}".format(project_name))
                        self._setting.flush(self._common, self._project)
                    else:
                        print("[ WAR ] canceled")
                else:
                    print("[ WAR ] cannot delete, because it is still running: {}".format(project_name))

    def _run_project(self, project, is_debug=False):
        dockercmd = "docker run -ti --rm "

        dockercmd += "--name clate_{} ".format(project['name'])

        for target, host in project['directory'].items():
            dockercmd += "-v {0}:/{1} ".format(host, target)

        for target, host in self._common['directory'].items():
            if target != 'Temp':
                dockercmd += "-v {0}:/{1} ".format(host, target)
            else:
                dockercmd += "-v {0}:/Temp ".format(host)

        if is_debug:
            dockercmd += "--entrypoint /bin/bash "

        dockercmd += "clate:{0}".format(project['version'])

        print("[ SUC ] run: {}".format(dockercmd))
        os.system(dockercmd)

    def _select_project(self):
        return self._interactor.list_select(self._project_names)

    def _select_version(self):
        global AVAILABLE_VERSION
        return self._interactor.list_select(AVAILABLE_VERSION)

    def _run(self, is_debug=False):
        project_num = self._select_project()
        if project_num != -1:
            self._run_project(self._project[project_num], is_debug)

    def _change_version(self):
        project_num = self._select_project()
        if project_num != -1:
            project = self._project[project_num]
            if self._docker.is_running(project['name']):
                print("[ WAR ] cannot change version, because it is still running: {}".format(project['name']))
                return

            version_num = self._select_version()
            if version_num != -1:
                project['version'] = AVAILABLE_VERSION[version_num]
                self._setting.flush(self._common, self._project)

                print("[ SUC ] version is updated - project: {0}, version: {1}".format(project['name'], project['version']))

    def run(self, project_name='clate', is_debug=False):
        idx = None
        try:
            idx = self._project_names.index(project_name)
        except ValueError:
            print("[ WAR ] no project: {0}".format(project_name))
            return

        self._run_project(self._project[idx], is_debug)


def parse():
    parser = argparse.ArgumentParser()
    parser.add_argument('-a', '--active', help='active project', default=None)
    parser.add_argument('-d', '--debug', help='run project with debug mode', action='store_true')

    return parser.parse_args()


def main():
    if not os.path.exists(CLATE_JSON):
        print("[ ERR ] ~/.clate.json is not existed.")
        return

    params = parse()

    if params.debug:
        if params.active:
            print("[ ERR ] debug and active cannot be together.")
            return

    clate = Clate()

    if params.active:
        clate.run(params.active)
    elif params.debug:
        clate.run(is_debug=True)
    else:
        clate.console()

    print("[ INF ] clate is closed")


if __name__ == '__main__':
    main()
